.\" Automatically generated by Pod::Man 2.28 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Crypt::Primes 3"
.TH Crypt::Primes 3 "2003-01-16" "perl v5.20.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Crypt::Primes \- Provable Prime Number Generator suitable for Cryptographic Applications.
.SH "VERSION"
.IX Header "VERSION"
.Vb 2
\& $Revision: 0.49 $
\& $Date: 2001/06/11 01:04:23 $
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    # generate a random, provable 512\-bit prime.
\&
\&    use Crypt::Primes qw(maurer);
\&    my $prime = maurer (Size => 512); 
\&
\&    # generate a random, provable 2048\-bit prime and report 
\&    # progress on console.  
\&
\&    my $another_prime = maurer ( 
\&                         Size => 2048, 
\&                         Verbosity => 1 
\&                        );           
\&
\&
\&    # generate a random 1024\-bit prime and a group 
\&    # generator of Z*(n).
\&
\&    my $hash_ref = maurer ( 
\&                    Size => 1024, 
\&                    Generator => 1, 
\&                    Verbosity => 1
\&                   );
.Ve
.SH "WARNING"
.IX Header "WARNING"
The codebase is stable, but the \s-1API\s0 will most definitely change in a future
release.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module implements Ueli Maurer's algorithm for generating large
\&\fIprovable\fR primes and secure parameters for public-key cryptosystems.  The
generated primes are almost uniformly distributed over the set of primes of
the specified bitsize and expected time for generation is less than the time
required for generating a pseudo-prime of the same size with Miller-Rabin
tests.  Detailed description and running time analysis of the algorithm can
be found in Maurer's paper[1].
.PP
Crypt::Primes is a pure perl implementation.  It uses Math::Pari for
multiple precision integer arithmetic and number theoretic functions.
Random numbers are gathered with Crypt::Random, a perl interface to
/dev/u?random devices found on most modern Unix operating systems.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
The following functions are availble for import.  They must be explicitely
imported.
.IP "\fBmaurer(%params)\fR" 4
.IX Item "maurer(%params)"
Generates a prime number of the specified bitsize.  Takes a hash as
parameter and returns a Math::Pari object (prime number) or a hash reference
(prime number and generator) when group generator computation is requested.
Following hash keys are understood:
.IP "\fBSize\fR" 4
.IX Item "Size"
Bitsize of the required prime number.
.IP "\fBVerbosity\fR" 4
.IX Item "Verbosity"
Level of verbosity of progress reporting.  Report is printed on \s-1STDOUT.\s0
Level of 1 indicates normal, terse reporting.  Level of 2 prints lots of
intermediate computations, useful for debugging.
.IP "\fBGenerator\fR" 4
.IX Item "Generator"
When Generator key is set to a non-zero value, a group generator of Z*(n) is
computed.  Group generators are required key material in public-key
cryptosystems like Elgamal and Diffie-Hellman that are based on
intractability of the discrete logarithm problem.  When this option is
present, \fImaurer()\fR returns a hash reference that contains two keys, Prime and
Generator.
.IP "\fBRelprime\fR" 4
.IX Item "Relprime"
When set to 1, \fImaurer()\fR stores intermediate primes in a class array, and
ensures they are not used during construction of primes in the future calls
to \fImaurer()\fR with Reprime => 1.  This is used by \fIrsaparams()\fR.
.IP "\fBIntermediates\fR" 4
.IX Item "Intermediates"
When set to 1, \fImaurer()\fR returns a hash reference that contains
(corresponding to the key 'Intermediates') a reference to an array of
intermediate primes generated.
.IP "\fBFactors\fR" 4
.IX Item "Factors"
When set to 1, \fImaurer()\fR returns a hash reference that contains
(corresponding to the key 'Factors') a reference to an array of
factors of p\-1 where p is the prime generated, and also (corresponding
to the key 'R') a divisor of p.
.IP "\fBrsaparams(%params)\fR" 4
.IX Item "rsaparams(%params)"
Generates two primes (p,q) and public exponent (e) of a \s-1RSA\s0 key pair. The
key pair generated with this method is resistant to iterative encryption
attack. See Appendix 2 of
[1] for more information.
.Sp
\&\fIrsaparams()\fR takes the same arguments as \fImaurer()\fR with the exception of
`Generator' and `Relprime'.  Size specifies the common bitsize of p an q.
Returns a hash reference with keys p, q and e.
.IP "\fBtrialdiv($n,$limit)\fR" 4
.IX Item "trialdiv($n,$limit)"
Performs trial division on \f(CW$n\fR to ensure it's not divisible by any prime
smaller than or equal to \f(CW$limit\fR.  The module maintains a lookup table of
primes (from 2 to 65521) for this purpose.  If \f(CW$limit\fR is not provided, a
suitable value is computed automatically.  \fItrialdiv()\fR is used by \fImaurer()\fR to
weed out composite random numbers before performing computationally
intensive modular exponentiation tests.  It is, however, documented should
you need to use it directly.
.SH "IMPLEMENTATION NOTE"
.IX Header "IMPLEMENTATION NOTE"
This module implements a modified FastPrime, as described in [1], to
facilitate group generator computation.  (Refer to [1] and [2] for
description and pseudo-code of FastPrime).  The modification involves
introduction of an additional constraint on relative size r of q.  While
computing r, we ensure k * r is always greater than maxfact, where maxfact
is the bitsize of the largest number we can factor easily.  This value
defaults to 140 bits.  As a result, R is always smaller than maxfact, which
allows us to get a complete factorization of 2Rq and use it to find a
generator of the cyclic group Z*(2Rq).
.SH "RUNNING TIME"
.IX Header "RUNNING TIME"
Crypt::Primes generates 512\-bit primes in 7 seconds (on average), and
1024\-bit primes in 37 seconds (on average), on my \s-1PII 300\s0 Mhz notebook.
There are no computational limits by design; primes upto 8192\-bits were
generated to stress test the code.  For detailed runtime analysis see [1].
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIlargeprimes\fR\|(1), \fICrypt::Random\fR\|(3), \fIMath::Pari\fR\|(3)
.SH "BIBLIOGRAPHY"
.IX Header "BIBLIOGRAPHY"
.IP "1 Fast Generation of Prime Numbers and Secure Public-Key Cryptographic Parameters, Ueli Maurer (1994)." 4
.IX Item "1 Fast Generation of Prime Numbers and Secure Public-Key Cryptographic Parameters, Ueli Maurer (1994)."
.PD 0
.IP "2 Corrections to Fast Generation of Prime Numbers and Secure Public-Key Cryptographic Parameters, Ueli Maurer (1996)." 4
.IX Item "2 Corrections to Fast Generation of Prime Numbers and Secure Public-Key Cryptographic Parameters, Ueli Maurer (1996)."
.IP "3 Handbook of Applied Cryptography by Menezes, Paul C. van Oorschot and Scott Vanstone (1997)." 4
.IX Item "3 Handbook of Applied Cryptography by Menezes, Paul C. van Oorschot and Scott Vanstone (1997)."
.IP "Documents 1 & 2 can be found under docs/ of the source distribution." 4
.IX Item "Documents 1 & 2 can be found under docs/ of the source distribution."
.PD
.SH "AUTHOR"
.IX Header "AUTHOR"
Vipul Ved Prakash, <mail@vipul.net>
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (c) 1998\-2001, Vipul Ved Prakash. All rights reserved. This code
is free software; you can redistribute it and/or modify it under the same
terms as Perl itself.
.SH "TODO"
.IX Header "TODO"
Maurer's algorithm generates primes of progressively larger bitsize using
a recursive construction method. The algorithm enters recursion with a
prime number and bitsize of the next prime to be generated. (Bitsizes of
the intermediate primes are computed using a probability distribution that
ensures generated primes are sufficiently random.) This recursion can be
distributed over multiple machines, participating in a competitive
computation model, to achieve close to best running time of the algorithm.
Support for this will be implemented some day, possibly when the next
version of Penguin hits \s-1CPAN.\s0
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 770:" 4
.IX Item "Around line 770:"
Can't have a 0 in =over 0
